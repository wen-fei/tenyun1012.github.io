<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解HotSpot虚拟机对象</title>
      <link href="/2019/11/14/java-jvm-2/"/>
      <url>/2019/11/14/java-jvm-2/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java虚拟机读书笔记-2-深入理解HotSpot虚拟机对象"><a href="#深入理解Java虚拟机读书笔记-2-深入理解HotSpot虚拟机对象" class="headerlink" title="深入理解Java虚拟机读书笔记(2): 深入理解HotSpot虚拟机对象"></a>深入理解Java虚拟机读书笔记(2): 深入理解HotSpot虚拟机对象</h1><p>为了理解虚拟机中数据的细节，比如如何创建、如何布局以及如何访问，必须具体到某一虚拟机和某一个内存区域。此处深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p><h2 id="一、对象的创建"><a href="#一、对象的创建" class="headerlink" title="一、对象的创建"></a>一、对象的创建</h2><p>反映到Java语言中，对象的创建通常不过是一个<code>new</code>关键字，然而反映到底层虚拟机上是如何呢？可以概括为以下三步：</p><ul><li><p><strong>类加载：</strong> 虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个<code>类的符号引用</code>，并且检查这个符号引用代表的类<code>是否已被加载、 解析和初始化过</code>。 如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存：</strong> 类加载通过后，虚拟机为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 这里一般有两种划分方式：</p><ul><li>Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是<code>把那个指针向空闲空间那边挪动一段与对象大小相等的距离</code>，这种分配方式称为<code>“指针碰撞”(Bump the Pointer)</code>。</li><li>Java堆中内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，<code>记录哪些内存块是可用的</code>，在分配的时候<code>从列表中找到一块足够大的空间划分给对象实例</code>，并更新列表上的记录，这种分配方式称为<code>“空闲列表”（Free List）</code>。 </li></ul><p>选择哪种分配方式<code>由Java堆是否规整决定</code>，而Java堆是否规整又由所采用的垃圾收集器<code>是否带有压缩整理功能决定</code>。 因此，在使用Serial、 ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。 </p><p>在分配内存时，另外一个需要考虑的问题是线程安全性。对象创建时一个非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的。例如可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。  针对此问题有两种解决方案：</p><ul><li>对分配内存空间的动作进行同步处理：即虚拟机采用CAS+失败重试的方式保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同得空间中进行，即每个线程在Java堆中预先分配一小块内存，称为<code>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</code> 。这有点类似于线程封闭技术，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。 </li></ul></li><li><p><strong>初始化：</strong> 内存分配完成后，需要对分配到的内存空间都进行初始化为<code>零值</code>（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。 这一步的动作，保证了对象的实例字段在Java代码中可以<code>不赋初值就可以直接使用</code>，程序能访问到这些字段的数据类型所对应的零值。 </p></li><li><p><strong>对象头设置</strong>：上面的初始化仅仅是通用的设置并且不包括对象头的设置，虚拟机接下来还要对对象进行更加丰富的设置，例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、 对象的GC分代年龄等信息。 这些信息存放在对象的<code>对象头（Object Header）</code>之中。 根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 </p></li><li><p><strong>对象init：</strong> 完成上面的工作以后，在虚拟机中其实一个对象已经产生了，但是从Java代码来看，其实<init>方法还没有执行，此时所有的字段还停留在初始化时设置的零值。一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行＜init＞方法，<code>把对象按照程序员的意愿进行初始化</code>，这样一个真正可用的对象才算完全产生出来。 </init></p></li></ul><p>至此，一个对象创建完成。那么，对象在内存中又是如何布局的呢？</p><h2 id="二、对象的内存布局"><a href="#二、对象的内存布局" class="headerlink" title="二、对象的内存布局"></a>二、对象的内存布局</h2><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：<code>对象头（Header）、实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。 </p><h3 id="2-1-对象头"><a href="#2-1-对象头" class="headerlink" title="2.1 对象头"></a>2.1 对象头</h3><p>对象头包括两部分信息，即对象运行时信息和类型指针。</p><p>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为<code>“Mark Word”</code>。  对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。  </p><p>对象头的另外一部分是类型指针，即<code>对象指向它的类元数据的指针</code>，虚拟机<code>通过这个指针来确定这个对象是哪个类的实例</code>。  并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，<code>查找对象的元数据信息并不一定要经过对象本身。</code>另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是<code>从数组的元数据中却无法确定数组的大小</code>。 </p><h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a>2.2 实例数据</h3><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，包括子类和父类的。关于存储顺序，受到虚拟机分配策略参数和字段在源码中定义顺序的影响。一般来说，相同宽度的字段总是被分配到一起，在此前提下，父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 </p><h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>这一部分不是必然存在的，仅仅起着占位符的作用，没有什么实际含义。由于HotSpot VM的自动内存管理系统要求<code>对象起始地址必须是8字节的整数倍</code>，换句话说，就是<code>对象的大小必须是8字节的整数倍</code>。 而对象头部分正好是8字节的倍数（1倍或者2倍），因此，<code>当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</code>。 </p><h2 id="三、对象的访问"><a href="#三、对象的访问" class="headerlink" title="三、对象的访问"></a>三、对象的访问</h2><p>Java程序通过<code>栈上的reference</code>数据来操作<code>堆上的具体对象</code>。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、 访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。 目前主流的访问方式有使用<code>句柄</code>和<code>直接指针</code>两种。 关于句柄，可以参考知乎的这个话题<a href="https://www.zhihu.com/question/27656256/answer/37556901" target="_blank" rel="noopener">句柄是什么？</a></p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>如果使用句柄访问，Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。如下图所示：</p><p><img src="C:%5CUsers%5Ctenyun%5CDesktop%5C%E6%89%BE%E5%B7%A5%E4%BD%9C%5C%E7%AC%94%E8%AE%B0%5Cimgs%5C1546826004438.png" alt="1546826004438"></p><h3 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h3><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问<code>类型数据</code>的相关信息，而reference中存储的直接就是对象地址，如下图所示：</p><p><img src="C:%5CUsers%5Ctenyun%5CDesktop%5C%E6%89%BE%E5%B7%A5%E4%BD%9C%5C%E7%AC%94%E8%AE%B0%5Cimgs%5C1546826074782.png" alt="1546826074782"></p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 </p><p>对于Hotspot而言，使用的是直接指针访问。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> HotSpot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理重要概念</title>
      <link href="/2019/11/14/java-jvm-1/"/>
      <url>/2019/11/14/java-jvm-1/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java虚拟机读书笔记-1-：内存管理重要概念"><a href="#深入理解Java虚拟机读书笔记-1-：内存管理重要概念" class="headerlink" title="深入理解Java虚拟机读书笔记(1)：内存管理重要概念"></a>深入理解Java虚拟机读书笔记(1)：内存管理重要概念</h1><p>说到Java内存管理，不得不先贴一张非常经典的图，如下所示：</p><p><img src="http://www.rowkey.me/images/blog_images/javamm/java-runtime-memory.jpg" alt="java-runtime-memory.jpg"></p><p>这些模块有些是线程私有的，有的则是线程共享的。下面一一对这些模块进行介绍：</p><h2 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h2><p>程序计数器一块比较小的内存空间，可以看做当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、 循环、 跳转、 异常处理、 线程恢复等基础功能都需要依赖这个计数器来完成。 </p><p>多线程执行时，实际上是轮流占用处理器来执行的，因此，不可避免的有线程切换，因为任何一个时刻，有且仅有一个线程中的指令占用处理器。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立<br>的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 </p><p>当执行的是java代码时，计数器记录的就是正在执行的虚拟机字节码指令的地址；如果是native方法，计数器值为空。</p><p>此处内存区域是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何内存溢出(OutOfMemoryError)情况的区域。</p><h2 id="二、Java虚拟机栈"><a href="#二、Java虚拟机栈" class="headerlink" title="二、Java虚拟机栈"></a>二、Java虚拟机栈</h2><p>虚拟机栈是线程私有的，它的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个<code>栈帧（Stack Frame）</code>用于存储局部变量表、 操作数栈、 动态链接、 方法出口等信息。 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 </p><p>常说的的Java内存区域分为堆内存（Heap）和栈内存(Stack)，这里的<strong>栈</strong>就是虚拟机栈，或者是虚拟机栈中局部变量表的部分。</p><p>所谓局部变量表，顾名思义，其中存放了编译期可以知道的各种基本数据类型（8种基本数据类型）、对象引用（reference类型，它不等同于对象本身，可能是一个<code>指向对象起始地址的引用指针</code>，也可能是<code>指向一个代表对象的句柄或其他与此对象相关的位置</code> ）和returnAddress类型(指向了一条字节码指令的地址 )。<code>局部变量表所需的内存空间在编译期间完成分配</code>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在<code>方法运行期间不会改变局部变量表的大小</code>。 </p><p>Java虚拟机规范规定了两种此区域会发生的异常：</p><ul><li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度 </li><li>OutOfMemoryError异常：如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以动态扩展） ，如果扩展时无法申请到足够的内存 </li></ul><h2 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 </p><p>这个可以说是Java为了妥协而产生的能够调用其他代码的产物，可以不需要深入理解。</p><h2 id="四、Java堆"><a href="#四、Java堆" class="headerlink" title="四、Java堆"></a>四、Java堆</h2><p>Java堆是虚拟机所管理的内存最大的一块，被所有线程所共享，虚拟机启动时自动创建。此内存区域主要目的是存放对象实例。根据Java虚拟机规范中描述，<code>所有的对象实例及数组都要在堆上分配</code>。但是随着技术的发展，JIT编译期日趋成熟，逃逸分析技术（后面介绍）逐渐成熟，栈上分配、标量替换优化技术等，所有对象分配在堆上也不是“绝对”了。</p><p>Java对既然存放了可以说是所有的对象，那么自然而然的，此处是垃圾收集器管理的主要区域。因此有时候Java堆也被称为“GC堆”。大部分的收集器都采用分代收集算法，所以Java堆还可以细分为新生代和老年代。其实还可以更加细分，其目的和作用不过是为了更加方便的跟快的分配和回收内存，与存放的内容无关，存放的都是对象实例。</p><p>Java堆可以是物理上不连续但逻辑上连续的内存空间。</p><h2 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h2><p>方法区也是各个线程共享的内存区域，用于存储已被虚拟机加载的<code>类信息、常量、静态变量、及时编译器编译后的代码</code>等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。 </p><p>对于常见的HotSpot虚拟机来说，方法区又称为“永久代（Permanent Generation)”，其原因是HotSpot虚拟机的设计团队选择<code>把GC分代收集扩展至方法区</code>，或者说<code>使用永久代来实现方法区</code>而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。  对于其他虚拟机（如J9和JRockit）来说，不存在永久代的概念。</p><p>目前来看，使用永久代来实现方法区，不是一个好的主意，因为容易遇到内存溢出问题（永久代有-XX：MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题 ）。在JDK1.7中的HotSpot中，已经把原本放在永久代的字符串常量池移除。</p><p>方法区的管理非常宽松，垃圾收集行为在此区域比较少见。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，但是类型卸载等条件非常苛刻，所以回收效果很差，但是又必须回收。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 </p><h2 id="六、运行时常量池"><a href="#六、运行时常量池" class="headerlink" title="六、运行时常量池"></a>六、运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放<code>编译期生成的各种字面量和符号引用</code>，这部分内容将在类加载后进入方法区的运行时常量池中存放。 一般来说，除了保存Class文件中描述的<code>符号引用</code>外，还会把翻译出来的<code>直接引用</code>也存储在运行时常量池中。 </p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，<code>运行期间也可能将新的常量放入池中。</code></p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 </p><h2 id="七、直接内存"><a href="#七、直接内存" class="headerlink" title="七、直接内存"></a>七、直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。  </p><p>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的<code>DirectByteBuffer对象</code>作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。 </p><p> 服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但<code>经常忽略直接内存</code>，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello3</title>
      <link href="/2019/11/13/hello3/"/>
      <url>/2019/11/13/hello3/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>papers-note-14</title>
      <link href="/2019/11/13/papers-note-14/"/>
      <url>/2019/11/13/papers-note-14/</url>
      
        <content type="html"><![CDATA[<h2 id="论文阅读笔记-14"><a href="#论文阅读笔记-14" class="headerlink" title="论文阅读笔记(14)"></a>论文阅读笔记(14)</h2><blockquote><p>论文题目：MARINE: Multi-relational Network Embeddings with Relational Proximity and Node Atributes</p><p>代码公开</p><p>发表于2019，www会议</p></blockquote><h3 id="主要创新点"><a href="#主要创新点" class="headerlink" title="主要创新点"></a>主要创新点</h3><p>对于齐次图和多关系图，提出新的表示学习模型。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> papers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> papers-notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello2</title>
      <link href="/2019/11/13/hello2/"/>
      <url>/2019/11/13/hello2/</url>
      
        <content type="html"><![CDATA[<h2 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h2><p>Hello World</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/21/hello-world/"/>
      <url>/2019/09/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy<span class="token keyword">done</span></code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
